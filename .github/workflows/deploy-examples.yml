name: Deploy Python Examples

on:
  push:
    branches: [ "main", "development" ]
    paths:
      - 'src/aws_durable_execution_sdk_python_testing/**'
      - 'examples/**'
      - '.github/workflows/deploy-examples.yml'
  pull_request:
    branches: [ "main", "development"]
    paths:
      - 'src/aws_durable_execution_sdk_python_testing/**'
      - 'examples/**'
      - '.github/workflows/deploy-examples.yml'
  workflow_dispatch:

env:
  AWS_REGION: us-west-2

permissions:
  id-token: write
  contents: read

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      examples: ${{ steps.get-examples.outputs.examples }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Get examples from catalog
      id: get-examples
      working-directory: ./examples
      run: |
        echo "examples=$(jq -c '.examples | map(select(.integration == true))' examples-catalog.json)" >> $GITHUB_OUTPUT

  integration-test:
    needs: setup
    runs-on: ubuntu-latest
    name: ${{ matrix.example.name }}
    strategy:
      matrix:
        example: ${{ fromJson(needs.setup.outputs.examples) }}
      fail-fast: false
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup SSH Agent
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: |
          ${{ secrets.LANGUAGE_SDK_SSH_PRIVATE_KEY }}
          ${{ secrets.TESTING_SSH_PRIVATE_KEY }}
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.13'

    - name: Configure AWS credentials
      if: github.event_name != 'workflow_dispatch' || github.actor != 'nektos/act'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: "${{ secrets.ACTIONS_INTEGRATION_ROLE_NAME }}"
        role-session-name: pythonTestingLibraryGitHubIntegrationTest
        aws-region: ${{ env.AWS_REGION }}

    - name: Install Hatch
      run: pip install hatch

    - name: Build examples
      run: hatch run examples:build

    - name: Deploy Lambda function - ${{ matrix.example.name }}
      env:
        AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        LAMBDA_ENDPOINT: ${{ secrets.LAMBDA_ENDPOINT }}
        INVOKE_ACCOUNT_ID: ${{ secrets.INVOKE_ACCOUNT_ID }}
        KMS_KEY_ARN: ${{ secrets.KMS_KEY_ARN }}
      run: |
        # Build function name
        EXAMPLE_NAME_CLEAN=$(echo "${{ matrix.example.name }}" | sed 's/ //g')
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          FUNCTION_NAME="${EXAMPLE_NAME_CLEAN}-Python-PR-${{ github.event.number }}"
        else
          FUNCTION_NAME="${EXAMPLE_NAME_CLEAN}-Python"
        fi
        
        # Extract handler file name
        HANDLER_FILE=$(echo "${{ matrix.example.handler }}" | sed 's/\.handler$//')
        
        echo "Deploying $HANDLER_FILE as $FUNCTION_NAME"
        hatch run examples:deploy "$HANDLER_FILE" "$FUNCTION_NAME"
        
        # Store function name for later steps
        echo "FUNCTION_NAME=$FUNCTION_NAME" >> $GITHUB_ENV

    - name: Invoke Lambda function - ${{ matrix.example.name }}
      env:
        LAMBDA_ENDPOINT: ${{ secrets.LAMBDA_ENDPOINT }}
      run: |
        echo "Testing function: $FUNCTION_NAME"
        aws lambda invoke \
          --function-name "$FUNCTION_NAME" \
          --cli-binary-format raw-in-base64-out \
          --payload '{"name": "World"}' \
          --region "${{ env.AWS_REGION }}" \
          --endpoint-url "$LAMBDA_ENDPOINT" \
          /tmp/response.json
        echo "Response:"
        cat /tmp/response.json

    - name: Find Durable Execution - ${{ matrix.example.name }}
      env:
        LAMBDA_ENDPOINT: ${{ secrets.LAMBDA_ENDPOINT }}
      run: |
        echo "Listing durable executions for function: $FUNCTION_NAME"
        aws lambda list-durable-executions \
          --function-name "$FUNCTION_NAME" \
          --region "${{ env.AWS_REGION }}" \
          --endpoint-url "$LAMBDA_ENDPOINT" \
          --cli-binary-format raw-in-base64-out \
          --status-filter SUCCEEDED \
          > /tmp/executions.json
        echo "Durable Executions:"
        cat /tmp/executions.json
        
        # Extract the first execution ARN for history retrieval
        EXECUTION_ARN=$(jq -r '.DurableExecutions[0].DurableExecutionArn // empty' /tmp/executions.json)
        echo "EXECUTION_ARN=$EXECUTION_ARN" >> $GITHUB_ENV

    - name: Get Durable Execution History - ${{ matrix.example.name }}
      if: env.EXECUTION_ARN != ''
      env:
        LAMBDA_ENDPOINT: ${{ secrets.LAMBDA_ENDPOINT }}
      run: |
        echo "Getting execution history for: $EXECUTION_ARN"
        aws lambda get-durable-execution-history \
          --durable-execution-arn "$EXECUTION_ARN" \
          --region "${{ env.AWS_REGION }}" \
          --endpoint-url "$LAMBDA_ENDPOINT" \
          --cli-binary-format raw-in-base64-out \
          > /tmp/history.json
        echo "Execution History:"
        cat /tmp/history.json

    - name: Cleanup Lambda function
      if: always()
      env:
        LAMBDA_ENDPOINT: ${{ secrets.LAMBDA_ENDPOINT }}
      run: |
        echo "Deleting function: $FUNCTION_NAME"
        aws lambda delete-function \
          --function-name "$FUNCTION_NAME" \
          --endpoint-url "$LAMBDA_ENDPOINT" \
          --region "${{ env.AWS_REGION }}" || echo "Function already deleted or doesn't exist"
